<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2019/11/24/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Vue-自定义指令"><a href="#Vue-自定义指令" class="headerlink" title="Vue 自定义指令"></a>Vue 自定义指令</h2><h5 id="Vue常用内置指令"><a href="#Vue常用内置指令" class="headerlink" title="Vue常用内置指令"></a>Vue常用内置指令</h5><p>v-if：表达式为true 当前标签才会展示到页面上  例如：</p>
<figure class="highlight plain"><figcaption><span>v-if</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;loading v-if=&quot;loading&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>v-else： <code>v-else</code> 指令来表示 <code>v-if</code> 的“else 块 必须紧跟在v-if或者v-else-if(2.1.0 新增)元素后面，否则将无法识别</p>
<figure class="highlight plain"><figcaption><span>v-if</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;!loading&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>v-model：双向数据绑定</p>
<p>v-bind：强制绑定解析表达式 </p>
<p>v-on：绑定事件监听，一般简写为@</p>
<p>v-text:更新元素的textContent</p>
<p>v-html:更新元素的innerHTML</p>
<p>v-show：通过控制display样式来控制显示/隐藏</p>
<p>V-for:遍历数组/对象</p>
<p>ref: 指定唯一标识，vue对象通过$els属性访问这个元素对象</p>
<p>V-cloak:防止闪现 ，与css配合 [v-cloak]{display:none}.</p>
<h5 id="Vue自定义指令"><a href="#Vue自定义指令" class="headerlink" title="Vue自定义指令"></a>Vue自定义指令</h5><p>需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;Vue-自定义指令&lt;/title&gt;</span><br><span class="line">	&lt;script  src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div id=&quot;test1&quot;&gt;</span><br><span class="line">		&lt;p v-upper-text=&quot;msg1&quot;&gt;&lt;/p&gt;</span><br><span class="line">		&lt;p v-lower-text=&quot;msg1&quot;&gt;&lt;/p&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;div id=&quot;test2&quot;&gt;</span><br><span class="line">		&lt;p v-upper-text=&quot;msg2&quot;&gt;&lt;/p&gt;</span><br><span class="line">		&lt;p v-lower-text=&quot;msg2&quot;&gt;&lt;/p&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	//定义全局指令</span><br><span class="line">	//el：指令属性所在的标签对象</span><br><span class="line">	//binding:包含指令相关信息的对象</span><br><span class="line">	Vue.directive(&apos;upper-text&apos;,(el,binding)=&gt;&#123;</span><br><span class="line">		console.log(binding);</span><br><span class="line">		el.textContent = binding.value.toUpperCase();</span><br><span class="line"></span><br><span class="line">	&#125;)</span><br><span class="line">	//创建根实例</span><br><span class="line">	new Vue(&#123;</span><br><span class="line">		el:&apos;#test1&apos;,</span><br><span class="line">		data:&#123;</span><br><span class="line">			msg1:&apos;hello world!&apos;,</span><br><span class="line">			msg2:&apos;right&apos;,</span><br><span class="line">		&#125;,</span><br><span class="line">		//注册局部指令</span><br><span class="line">		directives:&#123;</span><br><span class="line">			&apos;lower-text&apos;:function(el,binding)&#123;</span><br><span class="line">				el.textContent = binding.value.toLowerCase();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	new Vue(&#123;</span><br><span class="line">		el:&apos;#test2&apos;,</span><br><span class="line">		data:&#123;</span><br><span class="line">			msg1:&apos;hello world!&apos;,</span><br><span class="line">			msg2:&apos;right&apos;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h5><p>自定义指令提供以下bind、inserted、update、componentUpdated、unbind 钩子函数，可选配置<br>钩子函数可以接收以下几种参数</p>
<pre><code>el:指令所绑定的元素，可以用来直接操作DOM (当前文件指&lt;input/&gt; 元素)
binding:一个包含以下属性的对象
    name:指令名，不包含v-前缀
    value:指令的绑定值，例如 v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2
    oldValue:指令绑定的前一个值，只在update和conponentUpdated  钩子中可用，无论值是否改变都可用。
    expression:字符串形式的指令表达式，例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;
    arg:传递给指令的参数，可选 v-my-directive:foo 中，参数为 &quot;foo&quot;
    modifiers: 一个包含修饰符的对象，例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }
vnode:Vue编译生成的虚拟节点。
oldVnode:上一个虚拟节点，仅在update和componentUpdated钩子中可用

//除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。</code></pre><p>函数简写</p>
<p>大多数情况下，我们可能在bind和update的时候做重复动作，并且不关心其他的函数，那么就可以简写为以下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.directive(&apos;color-swatch&apos;,function(el,binding)&#123;</span><br><span class="line">    el.style.backgroundColor = binding.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>指令函数可以接受所有合法类型的Javascript表达式</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2019/11/24/Vue%E5%AD%A6%E4%B9%A0-v-model%20/</url>
    <content><![CDATA[<h2 id="V-model"><a href="#V-model" class="headerlink" title="V-model"></a>V-model</h2><h5 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h5><p>v-model指令可以在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素 v-model并不关心表单控件初始化所生成的值，它会选择Vue实例数据来作为具体的值。通俗理解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;&quot; v-model=&quot;msg&quot; name=&quot;123&quot; &gt; //value不生效，显示msg</span><br></pre></td></tr></table></figure>

<h5 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h5><p>哒哒哒 敲代码的声音，照着文档全都来一遍～～～</p>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>.lazy </p>
<p>默认情况下，v-model在input事件中同步输入框的值和数据，但是可以添加一个修饰符lazy,从而转变为change事件中同步 (当input框提交或者失去焦点的时候再同步)</p>
<p>.number </p>
<p>如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 <code>number</code> 给 <code>v-model</code> 来处理输入值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>.trim </p>
<p>如果要自动过滤用户输入的首尾空格，可以添加 <code>trim</code> 修饰符到 <code>v-model</code> 上过滤输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>

<p> <a href="https://www.jianshu.com/p/4147d3ed2e60" target="_blank" rel="noopener">看到一篇文章</a>，觉得人家写的很好，学习很多。</p>
<p>v-model只是vue的语法糖，Vue是单向数据流</p>
<pre><code>&lt;input v-model=&quot;sth&quot; name=&quot;&quot;&gt;
&lt;input v-bind:value=&quot;sth&quot; v-on:input = &quot;sth =$event.target.value&quot; name=&quot;&quot;&gt;</code></pre><p>上边两行代码是一个意思。当写下一个v-model指令的时候，其实vue帮我们把sth绑定到当前组件的value上，并且监听input方法，将获取到的输入内容赋值给sth </p>
<p><strong>给组件添加 v-model 属性时，默认会把 value 作为组件的属性，然后把 ‘input’ 值作为给组件绑定事件时的事件名</strong></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2019/10/31/vue%20textarea%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%91%E9%80%81/</url>
    <content><![CDATA[<h2 id="vue-textarea实现快捷键发送"><a href="#vue-textarea实现快捷键发送" class="headerlink" title="vue textarea实现快捷键发送"></a>vue textarea实现快捷键发送</h2><h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>最近在用vue做一个web网站的项目，里面有一个im的实时聊天功能。接入的是极光JMessage WebSDK 。</p>
<p> web端的聊天，肯定是需要回车发送消息的，方便得很有木有。</p>
<p>这里参考文档  <a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">Vue官网</a></p>
<h4 id="回车发送"><a href="#回车发送" class="headerlink" title="回车发送"></a>回车发送</h4><p>再监听键盘时间时，vue为我们提供了v-on  在监听键盘事件的时候添加按键修饰符</p>
<a id="more"></a>

<p>例如 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--监听键盘enter被按下时执行submit方法 --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter = &quot;submit&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Ctrl-enter换行"><a href="#Ctrl-enter换行" class="headerlink" title="Ctrl+enter换行"></a>Ctrl+enter换行</h4><p>vue 2.1.0 新增系统修饰符 .ctrl  .alt   .shift    .meta(mac的command,windows系统中对应windows徽标键)</p>
<p>看到这里，我就拿来写在了 代码里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这里由于我们发送消息可能存在多行并且需要一些格式的情况下，用了textarea </span><br><span class="line">&lt;textarea @keyup.enter=&quot;reply&quot; @keyup.ctrl.enter = &quot;nextLine&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>本以为大功告成了，结果自己一测试。发现按下ctrl+enter的时候也会触发reply 方法。尝试其他按键组合，只要按下enter键，无论和谁一起，都会触发reply 。 继续去看文档  发现vue 2.5.0之后新增了一个系统修饰符.exact</p>
<p>官方解释说 <code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>也就是说，想要有且只有enter被按下的时候执行reply  需要添加一个这样的修饰符，麻溜去改代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;textarea @keyup.enter.exact=&quot;reply&quot; @keyup.ctrl.enter = &quot;nextLine&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>再一运行，成功啦。还发现了个小问题，就是当enter按下的时候，自动换了一行然后才执行reply 。这里发现把组件换成input就可以了，换成input的同时发现ctrl+enter没法换行了。所以还是考虑用textarea了</p>
<p>想着在reply中阻止一下这个默认事件  写了event.preventDefault()和.prevent   都没起作用</p>
<p>考虑是否因为keyup松开键盘的时候默认事件已经执行了？</p>
<p>于是尝试把keyup换成keydown  再次运行。成功了 ！</p>
<p>keydown是按下键的时候执行，keyup是松开键 执行  </p>
<p>这里有一个知识点，就是keyup事件无法阻止浏览器默认事件。因为在<code>keypress</code>时，浏览器默认行为已经完成，如要阻止默认行为，必须在<code>keydown</code>或<code>keypress</code>时阻止</p>
<p>最后还有一点小问题就是在taxtarea中ctrl+enter换行总是无法自动定位到光标所在位置，导致换完行就看不见光标了。敲个字上去才能看到。在尝试过程中发现shift+enter换行很友好，页面也很流畅，体验比较好。在window和mac上各浏览器都测试，支持度比较高。所以和产品商量把快捷键换成 shift+enter.  至此，本次需求开发完成。</p>
<p>结贴啦</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2019/10/24/Vue.js%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h2 id="Vue-js数组对象属性更新"><a href="#Vue-js数组对象属性更新" class="headerlink" title="Vue.js数组对象属性更新"></a>Vue.js数组对象属性更新</h2><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let items =[</span><br><span class="line">    &#123;name:&apos;张三&apos;，age:14&#125;,</span><br><span class="line">    &#123;name:&apos;李四&apos;，age:16&#125;</span><br><span class="line">] </span><br><span class="line">items[0].age = 18;//页面不会更新</span><br><span class="line">items.length = 5;//页面不会更新</span><br></pre></td></tr></table></figure>

<p>这是因为 JavaScript的限制，使vue无法监听到以上方法改变的数组属性的变化。</p>
<p>为此，vue官方提供了Vue.set(Object/Array，key/inde, obj )方法来设置数组和对象的下一级属性，并且能够正常对此改变作出页面响应。</p>
<a id="more"></a>
<p>用上面现象举例，下面这种写法，就可以实现页面更新的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.set(items,0,&#123;name:&apos;张三&apos;，age:18&#125;);</span><br></pre></td></tr></table></figure>

<p>今天修改项目bug时遇到的问题，记录一下</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2019/10/23/vue%20router%20%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>今天自己打算用vue做一个单车管理后台的项目，使用到了vue-router 一些不改犯的小问题，在这里记录下。</p>
<h4 id="vue-router做什么"><a href="#vue-router做什么" class="headerlink" title="vue router做什么"></a>vue router做什么</h4><p>通俗些讲，vue router   就是把组件conponment和路由path一一对应起来 ，并且帮助应用实现页面的前进和后退</p>
<a id="more"></a>

<h4 id="简洁版使用方法"><a href="#简洁版使用方法" class="headerlink" title="简洁版使用方法"></a>简洁版使用方法</h4><p>1、创建组件（单个页面组件，例如login.vue,，home.vue, 和index.vue这些）</p>
<p>2、用组件创建route数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> routes = [</span><br><span class="line"></span><br><span class="line">     &#123;<span class="attr">path</span>:<span class="string">'/home'</span>,<span class="attr">component</span>:Home&#125;,</span><br><span class="line"></span><br><span class="line">     &#123;<span class="attr">path</span>:<span class="string">'login'</span>,<span class="attr">component</span>:Login&#125;,</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p> 3、实例化一个vueRouter对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Router from &apos;vue-router&apos;;</span><br><span class="line">let router = new Router(&#123;routes&#125;);</span><br></pre></td></tr></table></figure>

<p>4、把router对象配置到vue对象里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,//添加到new Vue方法里面</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure>

<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>全部配置完以后，npm run dev遇到了报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeError: Cannot read property &apos;$createElement&apos; of undefined</span><br><span class="line">    at render (eval at ./node_modules/cache-loader/dist/cjs.js?&#123;&quot;cacheDirectory&quot;:&quot;node_modules/.cache/vue-loader&quot;,&quot;cacheIdentifier&quot;:&quot;28f8696a-vue-loader-template&quot;&#125;!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Home.vue?vue&amp;type=template&amp;id=8dc7cce2&amp; (app.js:923), &lt;anonymous&gt;:6:16)</span><br><span class="line">    at eval (vue-router.esm.js?8c4f:1903)</span><br><span class="line">    at eval (vue-router.esm.js?8c4f:1930)</span><br><span class="line">    at Array.map (&lt;anonymous&gt;)</span><br><span class="line">    at eval (vue-router.esm.js?8c4f:1930)</span><br><span class="line">    at Array.map (&lt;anonymous&gt;)</span><br><span class="line">    at flatMapComponents (vue-router.esm.js?8c4f:1929)</span><br><span class="line">    at eval (vue-router.esm.js?8c4f:1865)</span><br><span class="line">    at iterator (vue-router.esm.js?8c4f:2120)</span><br><span class="line">    at step (vue-router.esm.js?8c4f:1846)</span><br></pre></td></tr></table></figure>

<p>检查发现是因为component写成了components </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">    &#123; path: &apos;/&apos;, redirect: &apos;/home&apos; &#125;,</span><br><span class="line">    &#123; path: &apos;/login&apos;, components: Login &#125;,//此处的components 应改为component</span><br><span class="line">    &#123; path: &apos;/home&apos;, components: Home &#125;//此处的components 应改为component</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>实在是不应该。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2019/10/21/github+hexo+ocean%20%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="github-hexo-ocean-快速搭建博客"><a href="#github-hexo-ocean-快速搭建博客" class="headerlink" title="github+hexo+ocean 快速搭建博客"></a>github+hexo+ocean 快速搭建博客</h1><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>终于有自己的博客了！作为一名前端开发媛，平时总是喜欢在本子上写写画画，一些流程图、脑图也是自己手写更有感觉。导致笔记和一些重要的东西，不能完整的记录下来。有了博客，以后就在这里更新了。markdown都是自己第一次正式用。下面就开始记录一下这个博客的搭建吧～</p>
<h5 id="准备工作-mac-环境"><a href="#准备工作-mac-环境" class="headerlink" title="准备工作(mac 环境)"></a>准备工作(mac 环境)</h5><p>假设你们的电脑上已经有了npm, node, git基本操作也没问题。</p>
<a id="more"></a>

<h4 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1. 安装hexo"></a>1. 安装hexo</h4><p> 打开终端，输入以下指令</p>
<p><code>npm install hexo -g</code></p>
<p>安装完成后，可以执行  <code>hexo -v</code> 查看版本</p>
<p>然后到任意一个你喜欢的目录下，新建一个文件夹 blog    </p>
<p>切换到blog目录下，执行<code>hexo init</code></p>
<p>然后可以看到这样的目录</p>
<ul>
<li><p>node_modules：是依赖包</p>
</li>
<li><p>public：存放的是生成的页面</p>
</li>
<li><p>scaffolds：命令生成文章等的模板</p>
</li>
<li><p>source：用命令创建的各种文章</p>
</li>
<li><p>themes：主题</p>
</li>
<li><p>_config.yml：整个博客的配置</p>
</li>
<li><p>db.json：source解析所得到的</p>
</li>
<li><p>package.json：项目所需模块项目的配置信息</p>
</li>
</ul>
<h4 id="2-github"><a href="#2-github" class="headerlink" title="2.github"></a>2.github</h4><p>这里我假设你已经有一个github账户</p>
<p>新建一个repository   取名为xxxx.github.io  按照这个规则创建才有用</p>
<p>回到终端中，配置github账户信息</p>
<p>创建ssh 终端中输入  <code>ssh-keygen -t rsa -C &quot;youremail&quot;</code></p>
<p>查看生成的ssh <code>cat id_rsa.pub</code></p>
<p>复制内容，放到github Setting -&gt; SSH and GPG keys -&gt;new SSH key</p>
<p>验证是否添加成功 ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p>
<h4 id="3-配置blog-运行"><a href="#3-配置blog-运行" class="headerlink" title="3.配置blog 运行"></a>3.配置blog 运行</h4><p>修改blog -&gt; _config.yml文件内的</p>
<p>如下所示，配上你自己的地址</p>
<p><code>deploy:
type: git
repo: https://github.com/YourgithubName/YourgithubName.github.io.git
branch: master</code></p>
<p>回到终端，cd 到新建的blog目录</p>
<p><code>hexo clean</code></p>
<p><code>hexo generate</code></p>
<p><code>hexo server</code></p>
<p>注：hexo 3.0把服务器独立成个别模块，需要单独安装：<code>npm i hexo-server</code>。</p>
<ul>
<li>打开浏览器输入：<code>http://localhost:4000</code></li>
<li>接着你就可以遇见天使的微笑了~</li>
</ul>
<h4 id="4-上传、部署到github"><a href="#4-上传、部署到github" class="headerlink" title="4.上传、部署到github"></a>4.上传、部署到github</h4><p>安装部署，先安装部署服务依赖</p>
<p><code>npm install hexo-deployer -git --save</code></p>
<p><code>hexo clean</code></p>
<p><code>hexo generate</code></p>
<p><code>hexo deploy</code></p>
<p>注意⚠️第一次deploy需要输入username和password（git的）</p>
<h4 id="5-见证奇迹"><a href="#5-见证奇迹" class="headerlink" title="5.见证奇迹"></a>5.见证奇迹</h4><p>在浏览器中输入<a href="https://yougithunname.github.io" target="_blank" rel="noopener">https://yougithunname.github.io</a> （repo的名字）就可以看到你的博客啦</p>
<h4 id="6-修改主题"><a href="#6-修改主题" class="headerlink" title="6.修改主题"></a>6.修改主题</h4><p>hexo默认主题landscape ,觉得不喜欢，可以去百度一搜一大把好看的主题。我这个话说找了好久，心水～～</p>
<p>跟主题相关的配置都在blog/themes 这个文件夹下</p>
<h4 id="7-写一篇文章发布吧"><a href="#7-写一篇文章发布吧" class="headerlink" title="7.写一篇文章发布吧"></a>7.写一篇文章发布吧</h4><p>其实很简单，每一篇博客都是单独的一个文件，推荐markdown 格式。所见即所得</p>
<p>新建文章：hexo new 文章名。这个文件是放在 blog/source/_posts路径下的，编辑完文件保存然后执行4的操作部署，就可以在浏览器看到你的文章啦</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>会坚持写博客的！会陆续研究统计，相册，配乐之类的内容，静待更新吧！</p>
]]></content>
  </entry>
</search>
